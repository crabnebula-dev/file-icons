#![no_std]

use core::{slice, str};
use fst::Map;
use lazy_static::lazy_static;

lazy_static! {
    static ref FILENAME_ICONS: Map<&'static [u8]> = {
        const FILENAME_ICONS_BYTES: &[u8] =
            include_bytes!(concat!(env!("OUT_DIR"), "/filename_icons.bin"));

        // the bytes are generated by fst in the build script, so we can use `unwrap_unchecked`
        unsafe { Map::new(FILENAME_ICONS_BYTES).unwrap_unchecked() }
    };
    static ref EXT_ICONS: Map<&'static [u8]> = {
        const EXT_ICONS_BYTES: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "/ext_icons.bin"));

        // the bytes are generated by fst in the build script, so we can use `unwrap_unchecked`
        unsafe {
            Map::new(EXT_ICONS_BYTES).unwrap_unchecked()
        }
    };
    static ref FOLDER_ICONS: Map<&'static [u8]> = {
        const FOLDER_ICONS_BYTES: &[u8] =
            include_bytes!(concat!(env!("OUT_DIR"), "/folder_icons.bin"));

        // the bytes are generated by fst in the build script, so we can use `unwrap_unchecked`
        unsafe{ Map::new(FOLDER_ICONS_BYTES).unwrap_unchecked() }
    };
}

#[no_mangle]
pub unsafe fn get_icon_for_file(data: *mut u8, len: usize) -> Option<u64> {
    let buf = unsafe { slice::from_raw_parts(data, len) };
    let path = str::from_utf8_unchecked(buf);

    let icon = FILENAME_ICONS.get(path.as_bytes()).or_else(|| {
        let ext = path.rsplit_once('.')?.1;

        EXT_ICONS.get(ext.as_bytes())
    });

    icon
}

#[no_mangle]
pub unsafe fn get_icon_for_folder(data: *mut u8, len: usize) -> Option<u64> {
    let buf = unsafe { slice::from_raw_parts(data, len) };
    let path = str::from_utf8_unchecked(buf);

    let icon = FOLDER_ICONS.get(path.as_bytes());

    icon
}
